\documentclass[12pt]{article}
\usepackage{alltt}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}
	
	\section*{Лабораторная работа №\,2 по курсу дискрeтного \\ анализа: словарь}
	
	\noindent Выполнила студентка группы 08-208 МАИ \textit{Понагайбо Анастасия}.
	
	\subsection*{Условие}
	
	\begin{enumerate}
		\item Постановка задачи: создать программную библиотеку, реализующую указанную структуру данных, на основе которой разработать программу-словарь. В словаре каждому ключу, представляющему из себя регистронезависимую последовательность букв английского алфавита длиной не более 256 символов, поставлен в соответствие некоторый номер, от 0 до 264 - 1.
		\item Вариант: 1, АВЛ-дерево.
	\end{enumerate}
	
	\subsection*{Метод решения}
    \begin{itemize}
		\item Реализовать АВЛ-дерево с функциями вставки, удаления, поиска, сохранения и загрузки.
		\item При считывании команды проверяем первый символ. Если первый символ '+', то считываем строку и число и вызываем функцию вставки в дерево. Если при вставке баланс дерева стал равен 2 или -2, то вызываем функцию балансировки. Если вставка прошла успешно, то выводим строку "ОК". Если слово уже есть в словаре, то выводим "Exist".
		\item Если первый символ '-', то считываем строку и вызываем функцию удаления. Если баланс дерева стал равен 2 или -2, то вызываем функцию балансировки. Если удаление прошло успешно, то выводим строку "ОК". Если такого слова в словаре нет, то выводим "NoSuchWord".
		\item Если первый символ '!', то считываем следующую строку. Если она равна "Save"{}, то сохраняем дерево в файл. Если "Load"{}, то загружаем дерево из файла. Если операция прошла успешно, то выводим строку "ОК". Иначе выводим сообщение об ошибке.
		\item В остальных случаях вызываем функцию поиска слова в словаре. Если слово найдено, то выводим строку "ОК"\ и соответствующий слову ключ. Иначе выводим строку "NoSuchWord".
	\end{itemize}

	\subsection*{Описание программы}
	
	\indent \textbf{Типы данных:}\\
	\indent\textit{struct node} - структура узла, хранящая ключ (\textit{key}), номер (\textit{value}), баланс (\textit{balance}) и ссылки на левый и правый узлы (\textit{left} и \textit{right}).\\
	\indent \textit{i64} - unsigned long long.\\
	
	\indent \textbf{Основные функции:}\\
	\textbf{node* RotateToLeft(node* root)} - левый поворот относительно \textit{root}.\\
	\textbf{node* RotateToRight(node* root)} - правый поворот относительно \textit{root}.\\
    \textbf{node* FixBalance(node* root)} - балансировка дерева с корнем \textit{root}.\\
    \textbf{node* Insert(char* k, i64 vl, node* root)} - вставка ключа \textit{k} с номером \textit{vl} в дерево с корнем \textit{root}.\\
    \textbf{void MinNode(node* root, node* mN)} - поиск в дереве с корнем \textit{root} элемента с минимальным ключом и копирование его в \textit{mN}.\\
    \textbf{node* RemoveMin(node* root)} - удаление минимального элемента дерева с корнем \textit{root}.\\
    \textbf{node* Remove(char* k, node* root)} - удаление элемента с ключом \textit{k} в дереве с корнем \textit{root}.\\
    \textbf{void Find(char* k, node* root)} - поиск элемента с ключом \textit{k} в дереве с корнем \textit{root}.\\
    \textbf{void Serialise(node* root, FILE* f)} - сохранение дерева с корнем \textit{root} в файле \textit{f}.\\
    \textbf{node* Deserialise(FILE* f)} - загрузка дерева из файла \textit{f}.\\
    \textbf{node* DeleteTree(node* root)} - удаление дерева с корнем \textit{root}.
    
	\subsection*{Дневник отладки}
	
	\indent \textbf{Runtime error at test 04.t, got signal 11}\\
	Добавлена дополнительная проверка баланса, под ключ выделяется динамический массив.\\
	\indent \textbf{Wrong answer at test 06.t}\\
	Добавлена проверка на корректность файла.\\
	\indent \textbf{Runtime error at test 12.t, got signal 11}\\
	Исправлена ошибка при загрузке дерева (удаление пустого дерева).

	\subsection*{Тест производительности}
	\begin{alltt}
		Количество введенных данных: 10,000:
		AVL-TREE: 24129 ms.
		     MAP: 65833 ms.
		
		Количество введенных данных: 100,000:
		AVL-TREE: 160925 ms.
		     MAP: 302040 ms.
		
		Количество введенных данных: 1,000,000:
		AVL-TREE: 2198439 ms.
		     MAP: 4109039 ms.
	\end{alltt}
	
	\subsection*{Выводы}

	АВЛ-дерево удобно использовать, если поиск по дереву происходит чаще, чем вставка и удаление, так как после них приходится часто производить повороты для обеспечения сбалансированности, что снижает быстродействие. Таким образом, использовать АВЛ-дерево для словаря выгодно, если поиск по нему происходит гораздо чаще, чем удаление и вставка.\\
	Основные трудности возникли при написании функций балансировки и загрузки дерева.

	
\end{document}